# Generate Random Number

## Setup

Creating a new project each time we create an example works but not optimal. Because `cargo build` command will compile all dependencies again. All of the examples will use [`tokio`], [`tower`], [`hyper`] and [`axum`]. Wouldn't it be good if we can do something about it?

We can create a workspace and put our projects inside it to not compile libraries over and over again. Lets do it.

First we need to create an empty directory.

```
mkdir workspace
```

Now create a `Cargo.toml`. But this `Cargo.toml` will have different stuff in it.

```toml
[workspace]

members = []
```

Inside square brackets we need to write name of our projects so `cargo` knows which directories to look into.

Lets bring our first app into this workspace.

Create a `first-app/` directory in workspace, copy `Cargo.toml` and `src/` into that directory.

In this repository command that does this will look like:

```
# From root of the repository
mkdir workspace/first-app/
cp -r 02-first-app/first-app/Cargo.toml 02-first-app/first-app/src/ workspace/first-app/
```

Now add `first-app` into square brackets. `Cargo.toml` of workspace should look like:

```toml
[workspace]

members = [
    "first-app"
]
```

Run `cargo build` in workspace directory to see it working.

Thankfully creating a project in workspace is much easier than bringing existing project into workspace. To do that:

Add the name of your new project in members.

```toml
[workspace]

members = [
    "first-app",
    "generate-random-number"
]
```

Then do `cargo new generate-random-number`. Done!

NOTE: `Cargo.toml` generated by `cargo new project-name` command contains a comment(comments start with "#" symbol in toml). We can just delete it.

For this project, we need [`tokio`], [`axum`], [`rand`] and [`serde`] crate as dependencies. Your `Cargo.toml` should look like:

```toml
[package]
name = "generate-random-number"
version = "0.1.0"
authors = ["Programatik <programatik29@gmail.com>"]
edition = "2018"

[dependencies]
tokio = { version = "1.9.0", features = ["full"] }
axum = "0.1.3"
rand = "0.8.4"
serde = { version = "1", features = ["derive"] }
```

## Code

In this tutorial, objective is generating a random number in a range defined by user. User will define range by `start` and `end` parameters in [query string].

We can start by copy pasting code of our first app. Then we can improve on that code.

```rust
use std::net::SocketAddr;
use axum::prelude::*;

#[tokio::main]
async fn main() {
    let app = route("/", get(|| async { "Hello, axum!" }));

    // Bind to 127.0.0.1(aka localhost) address and 3000 port.
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));

    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

Instead of using a closure(double pipes that generate anonymous function `||`) and async block, we can use an async function.

```rust
use std::net::SocketAddr;
use axum::prelude::*;

#[tokio::main]
async fn main() {
    let app = route("/", get(handler));

    // Bind to 127.0.0.1(aka localhost) address and 3000 port.
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));

    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn handler() -> &'static str {
    "Hello, axum!"
}
```

What is that scary looking `&'static str`? To explain it simply, it is the type of string literals(`"like this"`) that we define in rust language.

Difference of `async fn` from `fn` is that we can use `.await` in async functions. We must use `async fn` to create [`axum`] handler.

Now that we separated some part of our code, our code looks cleaner and ready for further modifications.

To make our job easier, [`axum`] has pre-built [extractors](https://docs.rs/axum/0.1.3/axum/extract/index.html#structs) ready to use. What an extractor does is extracting a part of request.

For this tutorial, we need [`Query`](https://docs.rs/axum/0.1.3/axum/extract/struct.Query.html) extractor.

We need a type that implements `Deserialize` to use this extractor. But what is that and how can we use it?

`Deserialize` is simply a trait from awesome de/serialization framework [`serde`] that parses a string as a rust type(in our case struct).

We can implement it easily by doing `#[derive(Deserialize)]` above our struct.

NOTE: `derive` feature that we enabled in dependencies section in serde enabled us to use it.

```rust
use serde::Deserialize;

#[derive(Deserialize)]
struct RangeParameters {
    start: usize,
    end: usize
}
```

Now we can easily get `start` and `end` query parameter values in our handler by doing:

```rust
use axum::extract::Query;

async fn handler(Query(range): Query<RangeParameters>) -> &'static str {
    "Hello, axum!"
}
```

Time to finally use [`rand`] crate to generate random number in specified range.

```rust
use axum::extract::Query;
use rand::{thread_rng, Rng};

async fn handler(Query(range): Query<RangeParameters>) -> String {
    thread_rng().gen_range(range.start..range.end).to_string()
}
```

We are not using `&'static str` anymore as our return type, because we are creating our string dynamically and not defining in compile time like `""`.

After bringing imports at the top, code should look like:

```rust
use std::net::SocketAddr;

use axum::prelude::*;
use axum::extract::Query;

use rand::{thread_rng, Rng};

use serde::Deserialize;

#[derive(Deserialize)]
struct RangeParameters {
    start: usize,
    end: usize,
}

#[tokio::main]
async fn main() {
    let app = route("/", get(handler));

    // Bind to 127.0.0.1(aka localhost) address and 3000 port.
    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));

    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn handler(Query(range): Query<RangeParameters>) -> String {
    thread_rng().gen_range(range.start..range.end).to_string()
}
```

Enter `http://localhost:3000/?start=50&end=100` on your browser.

## Links

Previous: [First App](../02-first-app)

Next: [Include Html](../04-include-html)

[`tokio`]: https://github.com/tokio-rs/tokio
[`tower`]: https://github.com/tower-rs/tower
[`hyper`]: https://github.com/hyperium/hyper
[`axum`]: https://github.com/tokio-rs/axum
[`rand`]: https://github.com/rust-random/rand
[`serde`]: https://github.com/serde-rs/serde
[query string]: https://docs.rs/http/0.2.4/http/uri/struct.Uri.html#method.query
